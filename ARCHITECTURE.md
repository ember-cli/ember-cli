## Overview

- **cli** parses args and calls the respective **command**
- **command** calls a sequence of **tasks**
- **tasks** do the actual work

## The different components of ember-cli
### cli()
cli is a small function that gets everything going.

Usage:
``` JavaScript
var cli = require('cli');

cli({
    cliArgs: argv, // Required
    inputStream: inputStream, // Required
    outputStream: outputStream // Required
  })
  .then(...);
```

### Commands
Located in `lib/commands/`. They get picked up by `requireAsHash()`
automatically.

The following file structure is expected (Demonstrated on the imaginary
command `develop-ember-cli`):
``` JavaScript
// e.g. commands/develop-ember-cli.js

var Command = require('../command');

module.exports = new Command({
  name: 'develop-ember-cli', // Optional, default is the filename
                             // Powered by some magic in getCallerFile()
  key: 'developEmberCLI', // Optional, default is the camelized name
  aliases: ['d', 'go-tomster'], // Optional, default is an empty array
  works: 'everywhere', // 'insideProject', 'outsideProject' or 'everywhere'
                       // Optional, default is 'insideProject'
  options: [ // Optional, default is an empty array
    {
      name: 'package-name', // Required
      key: 'packageName' // Optional, default is the camelized name
      type: String, // Required
      default: 'ember-cli', // Optional, default is undefined
      required: false // Optional, default is false
    },
    ...
  ],
  run: function(environment, options) { // Required
    // environment === { ui,
    //                   tasks, // Tasks hash generated by loadTasks()
    //                   commands, // Commands hash generated by loadCommands()
    //                   project: { directory, packageJSON }
    //                 }
    // options     === { packageName, ... }

    // Run tasks and return a promise
  },
  usageInstructions: function() { // Required
    return "Usage Instructions...";
  }
});
```

For more information on possible option types, see the [documentation for the
nopt library](https://github.com/npm/nopt).

Best practice is to use the `run()` function only to execute tasks. The real
work should be done in these tasks, then.

The promise returned by `run()` should either
- resolve to `undefined`
- reject with an `Error` instance if the error is unhandled
- or reject with `undefined` if it was handled. In this case the command
should log something via the `ui` first.

`requireAsHash()` assembles from the files in `commands/` a hash that looks
like this:
``` JavaScript
{
  developEmberCLI: require('commands/develop-ember-cli'),
  ...
}
```

### Tasks
Located in `lib/tasks`. They get picked up by `requireAsHash()` automatically.

Tasks do the real work. They should also do only one thing: For example there
are seperate `bower-install` and `npm-install` tasks, not just one unified
`install` task. And they should not call other tasks: For example
`install-blueprint` shouldn't call `npm-install` directly. That's because the
task sequence is determined by the command and thus should be declared there.
A tasks has to return a promise which resolves or rejects depending on whether
it ran through successfully or not.

The promise of a task should either
- fulfill to `undefined`
- reject with an `Error` instance if the error is unhandled
- or reject with `undefined` if it was handled. In this case the task should
log something via the `ui` first.

So, tasks don't have a return value per design.

The file format of a task looks like this:
``` JavaScript
// tasks/npm-install.js

var Task = require('../task');

module.exports = new Task({
  name: 'npm-install', // Optional, defaults to filename
                       // Powered by some magic in getCallerFile()
  key: 'npmInstall', // Optional, defaults to camelized name
  run: function(environment, options) {
    // environment === { ui, ... }

    // return promise
  }
});
```

`requireAsHash()` assembles from the files in `tasks/` a hash that looks like this:
``` JavaScript
{
  npmInstall: require('tasks/npm-install'),
  ...
}
```

## Style guide
- Everything Promise based
- Everything async (except require)
- Short files
- Tests, tests, tests
- Recommended line length <= 80 characters
- No `console.log`, we've our own logging system
- HTML and CSS: Double quotes, JavaScript: Single quotes
- Naming conventions
  - Dasherized (`some-thing`)
    - file, folder and package names
    - CSS classes
    - HTML tags and attributes
  - Camel case (`someThing`)
    - JavaScript (and JSON) propertys and variables
  - Pascal case (`SomeThing`)
    - JavaScript class names
  - Acronyms:
    - Okay: `url`, `id`, `rootURL` (property) or `URL`, `URLParser` (class)
    - Wrong: `Url`,`rootUrl`
    - We stick with how it's done in ember -> `rootURL`
- No comma separated var satements (`var cool = 123, supercool = 456;`)
- Line break at the end of every file

This list only contains style decisions not already covered by JSHint (e.g.
mandatory semicolons and other rules are omitted).

### Indentation
#### Aligned require statments
``` JavaScript
var RSVP    = require('rsvp');
var Promise = RSVP.Promise;
```

#### Multiline return statement
``` JavaScript
// Correct
return someFunction(
    someArgument,
    otherArgument
  );

// Wrong
return someFunction(
  someArgument,
  otherArgument
);
```

``` JavaScript
// Correct
return returnsAPromise()
  .then(...)
  .catch(...);

// Wrong
return retursAPromise().then(...)
.catch(...);
```

### Sync vs async
Since [JavaScript uses an event loop](http://nodejs.org/about/), the use of
blocking and compute intesive operations is discouraged. The general
recommendation is to use asynchronous operations.

However, there are exceptions. Node's own `require` statement is synchronous. It
is mainly used at program startup and only for a handful of files. Consequently,
although it being synchronous, using it is harmless. Same thing goes for
synchronous file globs in combination with `require` at startup.

The use of asynchronous code is mainly important for file walking operations
during runtime. For example for globbing a large amout of files or recursive
copying/deleting of folder structures. These operations generally take a long
time to complete and would if implemented synchronously disrupt progress
animations or delay server responses.

An advantage of asynchronous operations is that libraries can use it to
offer increased reliability. For example the popular file deletion library
rimraf uses `setTimeout` and a limited amount of retries after increasing
time intervals to [mitigate EBUSY errors on
windows](https://github.com/isaacs/rimraf/blob/master/rimraf.js#L20-L27).
Also, libraries can use asynchronicity to offload work onto worker threads. By
providing an asynchronous API fixes and optimizations can be implemented
transparently without breaking API compatibilty.
